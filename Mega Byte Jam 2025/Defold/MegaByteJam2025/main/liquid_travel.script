go.property("start_pos_x", 150)
go.property("start_pos_y", 150)
go.property("start_direction", 1)
go.property("debug", 0)
-- 1:x+ 2:x- 3:y+ 4:y-

function init(self)
	print("Instance created : " .. self.debug  )
	self.pos_x = self.start_pos_x
	self.pos_y = self.start_pos_y
	self.pos_z = 1

	self.tmp_time = 0
	self.time_to_move = 0.02

	go.set_position(vmath.vector3(self.pos_x, self.pos_y, self.pos_z))
	-- création du premier élément
	factory.create("#factory", go.get_position())
	-- définition de la direction de départ
	if self.start_direction == 1 then
		self.dir_x = 1
		self.dir_y = 0
	end
end

function final(self)

end

function update(self, dt)

end

local function update_current_tile(self)

	self.c_tile = tilemap.get_tile("/go_map#Map", "layer1", (self.pos_x / 64) + 1, (self.pos_y / 64) + 1)
	self.c_tile_top = tilemap.get_tile("/go_map#Map", "layer1", (self.pos_x / 64) + 1, (self.pos_y / 64) + 2)
	self.c_tile_down = tilemap.get_tile("/go_map#Map", "layer1", (self.pos_x / 64) + 1, (self.pos_y / 64))
	self.c_tile_left = tilemap.get_tile("/go_map#Map", "layer1", (self.pos_x / 64), (self.pos_y / 64) + 1)
	self.c_tile_right = tilemap.get_tile("/go_map#Map", "layer1", (self.pos_x / 64) + 2, (self.pos_y / 64) + 1)

end

local function get_tile_from_coord(x, y, self)
	return tilemap.get_tile("/go_map#Map", "layer1", (x / 64) + 1, (y / 64) + 1)
end

local function get_next_tile(self)
	local next_pixel_x
	local next_pixel_y
	if self.dir_x == 1 then
		next_pixel_x = self.pos_x + (go.get("#sprite", "size.x") / 2) + 1 
		next_pixel_y = self.pos_y
	elseif self.dir_x == -1 then
		next_pixel_x = self.pos_x - (go.get("#sprite", "size.x") / 2) - 1 
		next_pixel_y = self.pos_y
	elseif self.dir_y == 1 then
		next_pixel_x = self.pos_x
		next_pixel_y = self.pos_y + (go.get("#sprite", "size.y") / 2) + 1 
	elseif self.dir_y == -1 then
		next_pixel_x = self.pos_x
		next_pixel_y = self.pos_y - (go.get("#sprite", "size.y") / 2) - 1 
	end
	return get_tile_from_coord(next_pixel_x, next_pixel_y, self)
end

function fixed_update(self, dt)

	-- GESTION DU MOUVEMENT
	
	self.tmp_time = self.tmp_time + dt
	if self.tmp_time >= self.time_to_move then

		if self.dir_x == 1 and self.dir_y == 0 then
			self.pos_x = self.pos_x + 0.5
		elseif self.dir_x == -1 and self.dir_y == 0 then
			self.pos_x = self.pos_x - 0.5
		elseif self.dir_x == 0 and self.dir_y == 1 then
			self.pos_y = self.pos_y + 0.5
		elseif self.dir_x == 0 and self.dir_y == -1 then
			self.pos_y = self.pos_y - 0.5
		end

		-- Mouvement du carré
		go.set_position(vmath.vector3(self.pos_x, self.pos_y, self.pos_z))

		-- affichage d'un carré pour former une ligne
		if (self.dir_x == 1 or self.dir_x == -1) and self.dir_y == 0 then
			local t = self.pos_x - self.start_pos_x
			if t % 32 == 0 then
				factory.create("#factory", vmath.vector3(self.pos_x, self.pos_y, self.pos_z))
			end
		end
		if self.dir_x == 0 and (self.dir_y == 1 or self.dir_y == -1) then
			local t = self.pos_y - self.start_pos_y
			if t % 32 == 0 then
				factory.create("#factory", vmath.vector3(self.pos_x, self.pos_y, self.pos_z))
			end
		end

		self.tmp_time = 0
	end

	-- GESTION DES DIRECTIONS

	
	update_current_tile(self)

	self.next_tile = get_next_tile(self)
	
	if self.next_tile == 32 then
		msg.post("/main#main", "liquide_col", {tile = self.next_tile})
	end
	

end



function on_message(self, message_id, message, sender)

end

function on_input(self, action_id, action)

end

function on_reload(self)

end
