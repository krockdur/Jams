
local function test_connected(current_pipe_connections, previous_pipe_connections)
	local connection_to_previous = false
	for c_key, c_conn in ipairs( current_pipe_connections ) do
		for p_key, p_conn in ipairs( previous_pipe_connections ) do

			if p_conn == "bas" and c_conn == "haut" then
				connection_to_previous = true
			elseif p_conn == "haut"  and c_conn == "bas" then
				connection_to_previous = true
			elseif p_conn == "droite"  and c_conn == "gauche" then
				connection_to_previous = true
			elseif p_conn == "gauche"  and c_conn == "droite" then
				connection_to_previous = true
			end

		end 
	end

	return connection_to_previous
end

local function test_canalisation(self)
	
	local current_tile_x = 0
	local current_tile_y = 0
	local current_tile_type = 0
	local previous_tile_type = 0

	-- Paramètrage de la tuile de départ en fonction de son placement et de son orientation
	-- current_tile_type est la tuile suivante
	if self.starter_orientation == "bot" then
		
		current_tile_x = self.starter_x
		current_tile_y = self.starter_y - 1
		previous_tile_type = 10
		
	elseif self.starter_orientation == "top" then
		
		current_tile_x = self.starter_x
		current_tile_y = self.starter_y + 1
		previous_tile_type = 9
		
	elseif self.starter_orientation == "left" then
		
		current_tile_x = self.starter_x - 1
		current_tile_y = self.starter_y
		previous_tile_type = 11
		
	elseif self.starter_orientation == "right" then
		
		current_tile_x = self.starter_x + 1
		current_tile_y = self.starter_y
		previous_tile_type = 12
		
	end

	-- Ajout de la tuile de départ dans le tableau de continuité des pipe
	table.insert( self.board_continuity, { self.starter_x , self.starter_y, previous_tile_type } )


	local line_break = false

	while not line_break do
	
		-- recherche type de tuile	suivant
		current_tile_type = go.get( msg.url(nil, self.board_id[current_tile_y][current_tile_x], "pipe"), "number")

		-- recherche des connexions de type de tuile
		local tmp_previous_pipe_connections = self.pipes_connection[self.type_pipes[previous_tile_type]]
		local tmp_current_pipe_connections = self.pipes_connection[self.type_pipes[current_tile_type]]
		
		-- si la connexion est vraie alors ajout de la tuile à la self.board_continuity
		if test_connected(tmp_current_pipe_connections, tmp_previous_pipe_connections) == true then
			
			table.insert( self.board_continuity, {current_tile_x, current_tile_y, current_tile_type} )
		else
			line_break = true
		end

		previous_tile_type = current_tile_type

	end
	
end

function init(self)

	self.type_pipes = {
		"pipe_empty_1", 	-- ==
		"pipe_empty_2",		-- ||
		"pipe_empty_3",		-- +
		"pipe_empty_4_1",	-- ┐
		"pipe_empty_4_2",	-- ┌
		"pipe_empty_4_3",	-- ┘
		"pipe_empty_4_4",	-- └
		"empty",			--
		"starter_pipe_top", --  ┘└
		"starter_pipe_bot", --  ┐┌
		"starter_pipe_left", -- ==|
		"starter_pipe_right" -- |==
	}

	self.pipes_connection = {
		["pipe_empty_1"] = {"gauche", "droite"},
		["pipe_empty_2"] = {"haut", "bas"},
		["pipe_empty_3"] = {"gauche", "droite", "haut", "bas"},
		["pipe_empty_4_1"] = {"gauche", "bas"},
		["pipe_empty_4_2"] = {"droite", "bas"},
		["pipe_empty_4_3"] = {"gauche", "haut"},
		["pipe_empty_4_4"] = {"droite", "haut"},
		["starter_pipe_top"] = {"haut"},
		["starter_pipe_bot"] = {"bas"},
		["starter_pipe_left"] = {"gauche"},
		["starter_pipe_right"] = {"droite"}
	}
	
	--msg.post(".", "acquire_input_focus")
	
	
	-- Créer tous les pipes
	self.board_id = {}			-- table contenant les id de factory create
	self.board = {}				-- table contenant les type de tuiles
	self.board_continuity = {}	-- table représentant le board, avec à les pipes connectés

	for j = 1, 6 do
		self.board_id[j] = {}
		self.board[j] = {}
		self.board_continuity[j] = {}
		for i = 1, 11 do
			local id = factory.create("/board#board_factory", vmath.vector3(64*i+32, 64*j+32, 0.25), nil, {number = 8})
			self.board_id[j][i] = id
			self.board[j][i] = 8
			self.board_continuity[j][i] = 0
		end
	end

	-- Ajout du starter pipe
	-- suppression pipe en 5 4 pour test
	self.starter_orientation = "bot"
	self.starter_x = 5
	self.starter_y = 3
	
	go.delete(self.board_id[self.starter_y][self.starter_x]) -- suppression du pipe

	local id = factory.create("/board#board_factory", vmath.vector3(64 * self.starter_x + 32, 64 * self.starter_y + 32, 0.25), nil, {number = 9})
	self.board_id[self.starter_y][self.starter_x] = id
	self.board[self.starter_y][self.starter_x] = 9
	self.board_continuity[self.starter_y][self.starter_x] = 1
end

function final(self)

end

function update(self, dt)
	
end

function fixed_update(self, dt)

end

function on_message(self, message_id, message, sender)
	if message_id == hash("current_pipe") then 
		print("MESSAGE : " .. tostring(message.number) .. "     DE : " .. sender)
		self.current_pipe = message.number
	end
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_button_left") then
		if action.pressed then

		elseif action.released then
			
			local pos = vmath.vector3(action.x, action.y, 0)
			if (pos.x >= 64 and pos.x <= 64*12 and pos.y >= 64 and pos.y <= 64*7) then

				local ax, bx = (math.modf(pos.x / 64))
				local ay, by = (math.modf(pos.y / 64))
				
				go.delete(self.board_id[ay][ax])

				local id = factory.create("/board#board_factory", vmath.vector3(64*ax+32, 64*ay+32, 0.25), nil, {number = self.current_pipe})
				self.board_id[ay][ax] = id
				self.board[ay][ax] = self.current_pipe
				msg.post("/Script#incomming_pipes", "give_me_next_pipe")

				-- tests des continuités
				
			end
		end
	end

	if action_id == hash("mouse_button_right") then
		if action.released then
			-- test_canalisation(self)
			print("debug")
		end
	end
end

function on_reload(self)

end
